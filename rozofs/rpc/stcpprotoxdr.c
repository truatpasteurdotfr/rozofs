/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "stcpproto.h"
#include <rozofs/rozofs.h>

bool_t
xdr_stcpp_status_t (XDR *xdrs, stcpp_status_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_stcpp_status_ret_t (XDR *xdrs, stcpp_status_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_stcpp_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case STCPP_FAILURE:
		 if (!xdr_int (xdrs, &objp->stcpp_status_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_stcpp_profiler_t (XDR *xdrs, stcpp_profiler_t *objp)
{
	//register int32_t *buf;

	//int i;
	 if (!xdr_uint64_t (xdrs, &objp->uptime))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->now))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->vers, 20,
		sizeof (uint8_t), (xdrproc_t) xdr_uint8_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->stat, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->ports, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->remove, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->read_req, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->read, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->trans_inv, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->write, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->write_req, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->trans_forward, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->truncate, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->truncate_prj, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->truncate_prj_tmo, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->truncate_prj_err, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->read_prj, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->write_prj, 3,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->read_prj_tmo, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->read_prj_err, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->read_prj_enoent, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->read_blk_footer, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->write_prj_tmo, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->write_prj_err, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->read_sid_miss, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->write_sid_miss, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->truncate_sid_miss, 2,
		sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->io_process_ports, 32,
		sizeof (uint16_t), (xdrproc_t) xdr_uint16_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_stcpp_profiler_ret_t (XDR *xdrs, stcpp_profiler_ret_t *objp)
{
	//register int32_t *buf;

	 if (!xdr_stcpp_status_t (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case STCPP_SUCCESS:
		 if (!xdr_stcpp_profiler_t (xdrs, &objp->stcpp_profiler_ret_t_u.profiler))
			 return FALSE;
		break;
	case STCPP_FAILURE:
		 if (!xdr_int (xdrs, &objp->stcpp_profiler_ret_t_u.error))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
